#' Import V(D)J data
#'
#' @param input Object containing single cell data, if set to NULL a data.frame
#' containing V(D)J results will be returned
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from multiple runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of Seurat::Read10X(). Cell barcode prefixes can
#' also be provided using the cell_prefix argument.
#' @param prefix Prefix to add to new columns
#' @param cell_prefix Prefix to add to cell barcodes, this is helpful when
#' loading data from multiple runs into a single object. If NULL, cell barcode
#' prefixes are automatically generated in a similar manner as
#' Seurat::Read10X().
#'
#' For the V(D)J data to be successfully added to the object, the cell prefixes
#' must match the prefixes that are already present in the object. If the cell
#' prefixes are incorrect, import_vdj will be unable to assign the V(D)J data
#' to the correct cells.
#'
#' @param filter_chains Only include chains with at least one productive and
#' full length contig.
#' @param filter_paired Only include clonotypes with paired chains. For TCR
#' data each clonotype must have at least one TRA and TRB chain, for BCR data
#' each clonotype must have at least one IGH chain and at least one IGK or IGL
#' chain.
#' @param define_clonotypes Define clonotype IDs based on V(D)J data. This is
#' useful if the V(D)J datasets being loaded do not have consistent clonotype
#' IDs, i.e., clonotype1 is not the same across samples. Possible values are:
#'
#' - cdr3aa, define clonotypes based on the CDR3 amino acid sequence
#' - cdr3nt, define clonotypes based on the CDR3 nucleotide sequence
#' - cdr3_gene, define clonotypes based on the combination of the CDR3
#' nucleotide sequence and the V(D)J genes.
#'
#' When defining clonotypes, only productive full length chains will be used.
#' Set to NULL (default) to use the clonotype IDs already present in the input
#' data.
#'
#' @param include_mutations Include information about the number of
#' insertions/deletions/mismatches for each chain. This requires the
#' concat_ref.bam file from cellranger vdj to be present the directory provided
#' to vdj_dir. If include_mutations is TRUE, filter_chains is also
#' automatically set TRUE since indel data is only available for productive
#' chains.
#' @param aggr_dir Path to cellranger aggr output. To include mutation
#' information for each chain, also provide paths to the original cellranger
#' vdj directories using the vdj_dir argument.
#'
#' When using cellranger aggr results, cell barcode prefixes are automatically
#' generated by combining the 'donor' and 'origin' fields specified in the
#' cellranger aggr configuation file (i.e. 'donor_origin_'). To match
#' cellranger aggr output with mutation data found in the original
#' cellranger vdj output directories, be sure to provide matching cell barcode
#' prefixes to the cell_prefix argument.
#'
#' @param sep Separator to use for storing per cell V(D)J data
#' @return Single cell object or data.frame with added V(D)J data
#'
#' @examples
#' # Loading multiple datasets
#' vdj_dir <- c(
#'   system.file("extdata/bcr_1", package = "djvdj"),
#'   system.file("extdata/bcr_2", package = "djvdj")
#' )
#'
#' vdj_so <- import_vdj(tiny_so, vdj_dir)
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Specifying cell prefixes
#' # if cell prefixes are not specified when loading multiple datasets,
#' # prefixes will be automatically generated in a similar manner as
#' # Seurat::Read10X
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   cell_prefix = c("1", "2")
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Specifying cell prefixes using vector names
#' # if a named vector is passed, the names will be used as the cell prefixes
#' vdj_dir <- c(
#'   "1" = system.file("extdata/bcr_1", package = "djvdj"),
#'   "2" = system.file("extdata/bcr_2", package = "djvdj")
#' )
#'
#' vdj_so <- import_vdj(tiny_so, vdj_dir)
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Only include V(D)J data for productive full length chains
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   filter_chains = TRUE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Only include V(D)J data for cells with paired chains
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   filter_paired = TRUE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Defining clonotypes
#' # this is useful if the original clonotype IDs are not consistent across
#' # datasets, i.e. clonotype1 is not the same for all samples
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   define_clonotypes = "cdr3_gene"
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Omit indel information for each chain
#' # this information will be included if the file concat_ref.bam is present
#' # to speed up data import, omit indel information
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir = vdj_dir,
#'   include_mutations = FALSE
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Loading both BCR and TCR data
#' # load each dataset separately and assign unique column names using the
#' # prefix argument
#' bcr_dir <- system.file("extdata/bcr_1", package = "djvdj")
#' tcr_dir <- system.file("extdata/tcr_1", package = "djvdj")
#'
#' vdj_so <- import_vdj(
#'   tiny_so,
#'   vdj_dir     = bcr_dir,
#'   prefix      = "bcr_",
#'   cell_prefix = "1"
#' )
#'
#' vdj_so <- import_vdj(
#'   vdj_so,
#'   vdj_dir     = tcr_dir,
#'   prefix      = "tcr_",
#'   cell_prefix = "1"
#' )
#'
#' head(vdj_so@meta.data, 1)
#'
#' # Using import_vdj outside of Seurat
#' # SingleCellExperiment objects are also compatible, or if an input object is
#' # omitted, a data.frame containing the V(D)J data will be returned
#' vdj_sce <- import_vdj(tiny_sce, vdj_dir)
#'
#' head(vdj_sce@colData, 1)
#'
#' vdj_df <- import_vdj(vdj_dir = vdj_dir)
#'
#' head(vdj_df, 1)
#'
#' @export
import_vdj <- function(input = NULL, vdj_dir = NULL, prefix = "", cell_prefix = NULL, filter_chains = TRUE,
                       filter_paired = FALSE, define_clonotypes = NULL, include_mutations = TRUE,
                       aggr_dir = NULL, sep = ";") {

  # Check that vdj_dir or aggr_dir is provided
  load_aggr <- !is.null(aggr_dir)

  if (is.null(vdj_dir) && !load_aggr) {
    stop(
      "Must provide 'vdj_dir' or 'aggr_dir'"
    )
  }

  # Check that vdj_dir is also provided when loading mutation data for
  # aggr results
  if (load_aggr && is.null(vdj_dir) && include_mutations) {
    warning(
      "To include V(D)J mutation data when loading cellranger aggr results,",
      " paths to the original cellranger vdj output directories must be",
      " provided to the vdj_dir argument."
    )

    include_mutations <- FALSE
  }

  # Check that cell barcode prefixes are provided when loading mutation data
  # for cellranger aggr results
  if (
    load_aggr &&
    !is.null(vdj_dir) &&
    is.null(names(vdj_dir)) &&
    is.null(cell_prefix)
  ) {
    stop(
      "To differentiate between cells originating from each sample, cell barcode",
      " prefixes are generated for cellranger aggr results by combining",
      " the 'donor' and 'origin' fields specified in the cellranger aggr",
      " configuration file i.e. 'donor_origin_'.

To match V(D)J mutation data with",
      " cellranger aggr output, barcode prefixes must be provided using the",
      " vdj_dir or cell_prefix arguments. The prefixes must match the barcode",
      " prefixes generated for the cellranger aggr results."
    )
  }

  # When including indel data, only use productive full length chains
  if (!filter_chains) {
    filter_chains <- TRUE

    warning(
      "When include_mutations is TRUE, filter_chains is also automatically ",
      "set TRUE since indel data is only available for productive chains."
    )
  }

  # V(D)J columns to include
  cdr3_cols  <- c("cdr3", "cdr3_nt")  # list aa column first
  count_cols <- c("reads", "umis")
  gene_cols  <- c("v_gene", "d_gene", "j_gene", "c_gene")
  qc_cols    <- c("productive", "full_length")
  len_cols   <- paste0(cdr3_cols, "_length")

  # Columns containing per-cell info
  cell_cols <- c("barcode", "clonotype_id")

  # Optional aggr columns
  aggr_cols <- c("donor", "origin")

  # Columns containing per-chain info that needs to be collapsed for each cell
  sep_cols <- c(
    gene_cols, "chains",
    cdr3_cols, count_cols,
    qc_cols
  )

  # Format/check cell prefixes
  vdj_dir <- .format_cell_prefixes(vdj_dir, cell_prefix)

  # Load V(D)J data and add cell prefixes
  if (!is.null(aggr_dir)) {
    cell_cols <- c(cell_cols, aggr_cols)

    contigs <- .load_aggr_data(aggr_dir)

  } else {
    contigs <- .load_vdj_data(vdj_dir)
  }

  # vdj_cols should have all columns that should be included in output
  vdj_cols <- c(cell_cols, sep_cols)

  # For genes replace NAs
  # if a chain is missing a V(D)J segment, the gene name will be left empty
  # when read into R this results in an NA
  contigs <- purrr::map(contigs, ~ {
    dplyr::mutate(.x, across(all_of(gene_cols), tidyr::replace_na, "None"))
  })

  # Filter for productive full length chains
  if (filter_chains) {
    contigs <- purrr::map(contigs, dplyr::filter, !!!syms(qc_cols))
  }

  # Add indel info for each contig
  # if indel data is included, always filter for productive contigs since most
  # non-productive contigs are missing indel data
  if (include_mutations) {

    if (!is.null(aggr_dir)) {
      aggr_prfxs  <- paste0(sort(names(contigs)), collapse = ", ")
      indel_prfxs <- paste0(sort(names(vdj_dir)), collapse = ", ")

      if (!identical(aggr_prfxs, indel_prfxs)) {
        stop(
          "Cell barcode prefixes generated for the cellranger aggr output (",
          aggr_prfxs, ") do not match barcode prefixes specified using the",
          " vdj_dir or cell_prefix arguments (", indel_prfxs, ").

To differentiate between cells originating from each sample, cell barcode",
          " prefixes are generated for cellranger aggr results by combining",
          " the 'donor' and 'origin' fields specified in the cellranger aggr",
          " configuration file i.e. 'donor_origin_'.

To match V(D)J mutation data with",
          " cellranger aggr output, the barcode prefixes provided to the",
          " vdj_dir or cell_prefix arguments must match the barcode prefixes",
          " generated for the cellranger aggr results."
        )
      }
    }

    indels <- .load_muts(vdj_dir)

    if (!is.null(indels)) {
      indel_cols <- names(indels[[1]])
      indel_cols <- indel_cols[indel_cols != "contig_id"]

      # Join indel data
      indel_ctigs <- purrr::map2(
        contigs, indels,
        dplyr::left_join,
        by = "contig_id"
      )

      # Replace NAs with 0
      # contigs that did not have any mutations will have NAs
      indel_ctigs <- purrr::map(
        indel_ctigs,
        ~ mutate(
          .x,
          dplyr::across(all_of(indel_cols), replace_na, 0)
        )
      )

      contigs    <- indel_ctigs
      count_cols <- c(count_cols, indel_cols)
      sep_cols   <- c(sep_cols, indel_cols)
      vdj_cols   <- c(vdj_cols, indel_cols)
    }
  }

  # Classify input data as TCR or BCR
  vdj_class <- purrr::map_chr(contigs, .classify_vdj)
  vdj_class <- unique(vdj_class)

  if (length(vdj_class) > 1) {
    bad_class <- paste0(vdj_class, collapse = ", ")

    stop(
      "Multiple data types detected (", bad_class, "), provided data must be ",
      "either TCR or BCR. To add both TCR and BCR data to the same object, ",
      "run import_vdj separately for each and use the 'prefix' argument to ",
      "add distinct column names."
    )
  }

  if (identical(vdj_class, "BCR")) {
    cell_cols <- c(cell_cols, "exact_subclonotype_id")
    vdj_cols  <- c(vdj_cols, "exact_subclonotype_id")
  }

  # Check cell barcode overlap
  # use map to check each sample separately
  # give warning for low overlap
  # bind contig data.frames
  contigs <- purrr::imap_dfr(contigs, ~ .check_overlap(input, .x, .y))

  # Calculate CDR3 length
  # report length 0 if there is no reported CDR3 sequence
  contigs <- dplyr::mutate(
    contigs,
    across(
      all_of(cdr3_cols),
      ~ ifelse(.x == "None", 0, nchar(.x)),
      .names = "{.col}_length"
    )
  )

  sep_cols <- c(sep_cols, len_cols)
  vdj_cols <- c(vdj_cols, len_cols)

  # Remove contigs that do not have an assigned clonotype_id
  n_remove <- contigs$clonotype_id
  n_remove <- n_remove[is.na(n_remove)]
  n_remove <- length(n_remove)

  if (n_remove > 0) {
    warning(
      n_remove, " contig(s) do not have an assigned clonotype_id, ",
      "these contigs will be removed."
    )

    contigs <- dplyr::filter(contigs, !is.na(.data$clonotype_id))
  }

  # Check for NAs in data, additional NAs would indicate malformed input
  if (!all(stats::complete.cases(contigs))) {
    stop("Malformed input data, NAs are present, check input files.")
  }

  # Select V(D)J columns to keep
  contigs <- dplyr::select(contigs, all_of(vdj_cols))

  # Check if sep is already present in sep_cols
  sep <- .check_sep(contigs, sep_cols, sep)

  # Sum contig reads, UMIs, and mutations for chains since some chains are
  # supported by multiple contigs
  # In the vloupe browser the UMI count is summed, but the summed read count
  # and summed mutations do not always match
  grp_cols <- vdj_cols[!vdj_cols %in% count_cols]
  contigs  <- dplyr::group_by(contigs, !!!syms(grp_cols))

  contigs <- dplyr::summarize(
    contigs,
    across(all_of(count_cols), sum),
    .groups = "drop"
  )

  # Determine which clonotypes are paired
  contigs <- .identify_paired(contigs)

  cell_cols <- c(cell_cols, "paired")
  vdj_cols  <- c(vdj_cols, "paired")

  if (filter_paired) {
    contigs <- dplyr::filter(contigs, .data$paired)
  }

  # Order chains and CDR3 sequences
  # when rows are collapsed, the cdr3 sequences must be in the same order for
  # every cell. This is required so the cdr3 columns can be used directly as
  # the clonotype ID
  contigs <- dplyr::arrange(
    contigs,
    .data$barcode, .data$chains, .data$cdr3_nt
  )

  # Extract isotypes from c_gene for IGH chain (for BCR data only)
  if (vdj_class %in% c("BCR", "Multi")) {
    contigs <- .extract_isotypes(contigs)

    cell_cols <- c(cell_cols, "isotype")
    vdj_cols  <- c(vdj_cols,  "isotype")
  }

  # Collapse chains into a single row for each cell
  # include columns containing per-cell info groups so they are included in the
  # summarized results
  contigs <- dplyr::group_by(contigs, !!!syms(cell_cols))

  meta <- summarize(
    contigs,
    across(
      all_of(sep_cols),
      ~ paste0(as.character(.x), collapse = sep)
    ),
    n_chains = n(),
    .groups = "drop"
  )

  # Reorder columns
  meta <- dplyr::relocate(meta, .data$paired, .after = "full_length")
  meta <- dplyr::relocate(meta, all_of(len_cols), .after = last(cdr3_cols))
  meta <- dplyr::relocate(meta, .data$n_chains, .after = "chains")
  meta <- dplyr::relocate(meta, all_of(gene_cols), .after = last(len_cols))

  if (vdj_class %in% c("BCR", "Multi")) {
    meta <- dplyr::relocate(meta, .data$isotype, .after = "c_gene")
  }

  # Check for duplicated cell barcodes
  if (any(duplicated(meta$barcode))) {
    stop("Malformed input data, multiple clonotype_ids are associated with the same cell barcode.")
  }

  # Allow user to redefine clonotypes
  res <- tibble::column_to_rownames(meta, "barcode")

  if (!is.null(define_clonotypes)) {
    clone_cols <- list(
      cdr3aa    = "cdr3",
      cdr3nt    = "cdr3_nt",
      cdr3_gene = c("cdr3_nt", gene_cols[gene_cols != "c_gene"])
    )

    if (!define_clonotypes %in% names(clone_cols)) {
      stop(
        "define_clonotypes must be one of ",
        paste0(names(clone_cols), collapse = ", "), "."
      )
    }

    clone_cols <- clone_cols[[define_clonotypes]]

    res <- define_clonotypes(
      res,
      vdj_cols      = clone_cols,
      filter_chains = qc_cols
    )
  }

  # Filter to only include cells with valid clonotype_id
  # cells with missing clonotype have a clonotype_id of 'None'
  res <- dplyr::filter(res, .data$clonotype_id != "None")

  if (nrow(res) == 0) {
    warning("No valid clonotypes present, check input data.")
  }

  # Add prefix to V(D)J columns
  res <- dplyr::rename_with(res, ~ paste0(prefix, .x))

  # Add new meta.data to input object
  res <- .merge_meta(input, res)

  res
}

#' Format and add cell prefixes
#'
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from several runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of the Read10X function found in the Seurat
#' package. Cell barcode prefixes can also be provided using the cell_prefix
#' argument.
#' @param cell_prefix Prefix to add to cell barcodes, this is helpful when
#' loading data from multiple runs into a single object. If set to NULL, cell
#' barcode prefixes will be automatically generated in a similar way as the
#' Read10X function found in the Seurat package.
#' @param sep Separator to use when appending prefixes to cell barcodes, set to
#' NULL to not add a separator
#' @return Paths provided to vdj_dir with cell prefixes added as names
#' @noRd
.format_cell_prefixes <- function(vdj_dir, cell_prefix, sep = "_") {

  if (is.null(vdj_dir)) {
    return(vdj_dir)
  }

  res <- vdj_dir

  # If vdj_dir is not named, check cell_prefix
  if (is.null(names(res))) {

    # If no prefixes, auto-generate, do not add prefix if only one sample
    # Read10X() will add the prefix, "1_", "2_", "3_", etc. for each sample
    if (is.null(cell_prefix)) {
      cell_prefix <- ""

      if (length(res) > 1) {
        cell_prefix <- paste0(seq_along(res), "_")
      }
    }

    # Check there is a cell prefix provided for each path
    if (length(res) != length(cell_prefix)) {
      stop("cell_prefix must be the same length as vdj_dir (", length(res),").")
    }

    names(res) <- cell_prefix
  }

  # Check for NAs in cell prefixes
  if (any(is.na(names(res)))) {
    stop("Cell prefixes cannot include NAs.")
  }

  # Check for duplicated cell prefixes
  if (any(duplicated(names(res)))) {
    dups <- duplicated(names(res))
    dups <- names(res)[dups]
    dups <- paste0(dups, collapse = ", ")

    warning("Some cell barcode prefixes are duplicated: ", dups)
  }

  # Add separator if one is not included in cell prefixes
  if (!is.null(sep)) {
    sep_regex <- paste0(sep, "$")

    nms <- names(res) != "" & !grepl(sep_regex, names(res))

    names(res)[nms] <- paste0(names(res)[nms], sep)
  }

  res
}

#' Load V(D)J data
#'
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from several runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of the Read10X function found in the Seurat
#' package.
#' @param contig_file cellranger vdj output file containing data for each
#' contig annotation
#' @param chk_none Value of 'None' will be replaced with FALSE for the
#' specified columns and converted to logical
#' @return List containing one data.frame for each path provided to vdj_dir
#' @importFrom readr read_csv cols
#' @noRd
.load_vdj_data <- function(vdj_dir, contig_file = "filtered_contig_annotations.csv",
                           chk_none = c("productive", "full_length")) {

  # Check for file and return path
  res <- purrr::map_chr(vdj_dir, .get_vdj_path, file = contig_file)

  # Load data
  res <- purrr::map(
    res,
    readr::read_csv,
    col_types = readr::cols(),
    progress  = FALSE
  )

  # Add cell prefixes and replace 'None' in productive with FALSE
  res <- purrr::imap(res, ~ {
    d <- dplyr::filter(.x, is_cell)

    d <- .replace_none(d, chk_none)

    d <- dplyr::mutate(d, barcode = paste0(.y, .data$barcode))

    d <- dplyr::rename(
      d,
      chains       = .data$chain,
      clonotype_id = .data$raw_clonotype_id
    )

    d
  })

  res
}

#' Load data from cellranger aggr
#'
#' @param aggr_dir Directory containing the output from cellranger aggr
#' @param contig_file cellranger aggr output file containing data for each
#' contig annotation
#' @param chk_none Value of 'None' will be replaced with FALSE for the
#' specified columns and converted to logical
#' @return data.frame
#' @importFrom readr read_csv cols
#' @noRd
.load_aggr_data <- function(aggr_dir, contig_file = "filtered_contig_annotations.csv",
                            chk_none = c("productive", "full_length")) {

  # Check for file and return path
  res <- .get_vdj_path(aggr_dir, file = contig_file)

  # Load data
  res <- readr::read_csv(
    res,
    col_types = readr::cols(),
    progress  = FALSE
  )

  # Filter for contigs in cells
  res <- dplyr::filter(res, is_cell)

  # Replace 'None' with FALSE for QC columns
  res <- .replace_none(res, chk_none)

  res <- dplyr::rename(
    res,
    chains       = .data$chain,
    clonotype_id = .data$raw_clonotype_id
  )

  # Add donor and origin as barcode prefix and split data.frame into list
  bc_prfx <- paste0(res$donor, "_", res$origin, "_")

  res <- dplyr::mutate(res, barcode = paste0(bc_prfx, .data$barcode))

  res <- split(res, bc_prfx)

  res
}

#' Replace 'None' with FALSE
#'
#' @param df_in data.frame
#' @param clmns Columns to replace 'None' and convert to logical
#' @return data.frame
#' @noRd
.replace_none <- function(df_in, clmns) {

  res <- dplyr::rowwise(df_in)

  res <- dplyr::mutate(
    res,
    dplyr::across(.cols = all_of(clmns), ~ {
      ifelse(
        !is.logical(.x),
        as.logical(gsub("None", "FALSE", .x)),
        .x
      )
    })
  )

  res <- dplyr::ungroup(res)

  res
}

#' Load mutation information for each contig
#'
#' @param vdj_dir Directory containing the output from cellranger vdj. A vector
#' or named vector can be given to load data from several runs. If a named
#' vector is given, the cell barcodes will be prefixed with the provided names.
#' This mimics the behavior of the Read10X function found in the Seurat
#' package.
#' @param bam_file bam file from cellranger vdj containing alignment data comparing
#' each contig with the germline reference
#' @return List containing one data.frame for each path provided to vdj_dir
#' @importFrom Rsamtools scanBam
#' @noRd
.load_muts <- function(vdj_dir, bam_file = "concat_ref.bam",
                       airr_file = "airr_rearrangement.tsv") {

  # Check for bam file and return path
  # if bam is missing for any sample, return NULL
  # do not want extra NAs in the V(D)J data columns
  bam_file <- purrr::map_chr(
    vdj_dir,
    .get_vdj_path,
    file = bam_file,
    warn = TRUE
  )

  if (any(is.na(bam_file))) {
    return(NULL)
  }

  # Check for AIRR file and return path
  # if AIRR is missing for any sample, set to NA
  airr_file <- purrr::map_chr(
    vdj_dir,
    .get_vdj_path,
    file = airr_file,
    warn = TRUE
  )

  if (any(is.na(airr_file))) {
    airr_file[!is.na(airr_file)] <- NA
  }

  # Extract mutations from bam file
  mut_coords <- purrr::map(bam_file, .extract_mut_coords)

  # Extract VDJ coords from AIRR
  vdj_coords <- purrr::map(airr_file, .extract_vdj_coords)

  # Map mutations to VDJ segments
  res <- purrr::map2(mut_coords, vdj_coords, .map_muts)

  res
}

.extract_mut_coords <- function(bam_file) {

  bam_info <- Rsamtools::scanBam(bam_file)[[1]]

  wdths <- as.data.frame(bam_info$seq@ranges)$width

  bam_info <- tibble::tibble(
    cigar     = bam_info$cigar,
    contig_id = bam_info$qname,
    width     = wdths
  )

  bam_info <- dplyr::filter(
    bam_info,
    grepl("_contig_[0-9]+$", .data$contig_id)
  )

  # Get 0-based coordinates for mutations
  # set width of deletion coordinates as 0
  res <- dplyr::mutate(
    bam_info,
    n    = .str_extract_all(cigar, "[0-9]+(?=[^0-9])"),
    type = .str_extract_all(cigar, "(?<=[0-9])[^0-9]{1}")
  )

  res <- tidyr::unnest(res, c(n, type))
  res <- dplyr::group_by(res, contig_id)

  res <- dplyr::mutate(
    res,
    n     = as.numeric(n),
    len   = ifelse(type != "D", n, 0),
    end   = cumsum(len),
    start = lag(end, default = 0)
  )

  res <- dplyr::ungroup(res)
  res <- dplyr::filter(res, type != "=")
  res <- dplyr::select(res, contig_id, width, start, end, type, n)

  res
}

.extract_vdj_coords <- function(airr_file) {

  if (is.na(airr_file)) {
    return(NA)
  }

  airr <- readr::read_tsv(
    airr_file,
    col_types = readr::cols(),
    progress  = FALSE
  )

  # Pull V(D)J gene coordinates from AIRR file
  # tidyr::extract is much faster than tidyr::separate
  coord_cols_re <- "^([vdjc])(?=_).*(?<=_)(start|end)$"

  res <- dplyr::select(
    airr,
    contig_id = sequence_id,
    dplyr::matches(coord_cols_re, perl = TRUE)
  )

  if (ncol(res) == 1) {
    stop("V(D)J coordinates not found, check ", airr_file)
  }

  res <- tidyr::pivot_longer(res, -contig_id)
  res <- dplyr::filter(res, !is.na(.data$value))
  res <- tidyr::extract(res, name, c("seg", "pos"), coord_cols_re)
  res <- tidyr::pivot_wider(res, names_from = pos)
  res <- dplyr::mutate(res, start = start - 1)
  res <- dplyr::select(res, contig_id, start, end, seg)

  res
}

.map_muts <- function(mut_coords, vdj_coords) {

  mut_key <- c(
    I = "ins",
    D = "del",
    X = "mis"
  )

  mut_coords <- dplyr::mutate(mut_coords, type = dplyr::recode(type, !!!mut_key))

  # Count total mutations
  all_muts <- dplyr::mutate(mut_coords, type = paste0("all_", .data$type))

  all_muts <- dplyr::group_by(all_muts, contig_id, width, type)
  all_muts <- dplyr::summarize(all_muts, n = sum(n), .groups = "drop")

  # If no airr, return mutation totals
  if (identical(vdj_coords, NA)) {
    res <- all_muts %>%
      tidyr::pivot_wider(
        names_from  = type,
        values_from = n,
        values_fill = 0
      )

    res <- dplyr::mutate(
      res,
      across(
        starts_with("all_"),
        ~ .x / width,
        .names = "{.col}_freq"
      )
    )

    return(res)
  }

  # Intersect mutations with VDJ gene coordinates for each contig
  # some annotations overlap each other! Example: AAACCTGAGAACTGTA-1_contig_1
  # left_join + mutate is much faster than valr::bed_intersect, probably due
  # to the extreme number of "chromosomes"
  vdj_muts <- dplyr::left_join(
    mut_coords, vdj_coords,
    by = "contig_id",
    suffix = c("", ".y")
  )

  vdj_muts <- dplyr::filter(vdj_muts, start < end.y & end > start.y)

  vdj_muts <- dplyr::mutate(
    vdj_muts,
    new_start = ifelse(start >= start.y, start, start.y),
    new_end   = ifelse(end <= end.y, end, end.y),
    n         = ifelse(type != "del", new_end - new_start, n)
  )

  vdj_muts <- dplyr::group_by(vdj_muts, contig_id, width, type, seg)
  vdj_muts <- dplyr::summarize(vdj_muts, n = sum(n), .groups = "drop")
  vdj_muts <- tidyr::unite(vdj_muts, type, seg, type, sep = "_")

  # Add total mutations to output and calculate mutation frequency
  mut_cols <- c("v", "d", "j", "c")
  mut_cols <- purrr::map(mut_cols, paste0, "_", mut_key)
  mut_cols <- purrr::reduce(mut_cols, c)
  all_cols <- paste0("all_", unname(mut_key))
  all_cols <- c(all_cols, paste0(all_cols, "_freq"))
  mut_cols <- c(mut_cols, all_cols)

  res <- dplyr::bind_rows(vdj_muts, all_muts)

  res <- tidyr::pivot_wider(
    res,
    names_from  = type,
    values_from = n,
    values_fill = 0
  )

  res <- dplyr::mutate(
    res,
    across(
      starts_with("all_"),
      ~ round(.x / width, 6),
      .names = "{.col}_freq"
    )
  )

  # Add 0s for missing columns and set column order
  # these are segments with no mutations for any chain
  missing_cols <- mut_cols[!mut_cols %in% names(res)]

  res[, missing_cols] <- 0

  res <- res[, c("contig_id", mut_cols)]

  res
}

#' Check for V(D)J data file in provided directory
#'
#' @param vdj_dir Directory containing the output from cellranger vdj
#' @param file Name of cellranger vdj output file
#' @param warn When the file is not found display a warning message instead of
#' an error
#' @return path to cellranger vdj output file
#' @noRd
.get_vdj_path <- function(vdj_dir, file, warn = FALSE) {

  # Check vdj_dir for file
  # try adding "outs" to path if file not found
  path <- case_when(
    file.exists(file.path(vdj_dir, file))         ~ file.path(vdj_dir, file),
    file.exists(file.path(vdj_dir, "outs", file)) ~ file.path(vdj_dir, "outs", file)
  )

  if (is.na(path)) {
    fun <- stop

    if (warn) {
      fun <- warning
    }

    fun(file, " not found in ", vdj_dir, ".")
  }

  path
}

#' Check for separator in data.frame
#'
#' @param df_in data.frame
#' @param sep_cols Names of columns to check for sep
#' @param sep Separator to use for storing V(D)J data
#' @return Separator with white space stripped
#' @noRd
.check_sep <- function(df_in, sep_cols, sep) {
  if (is.null(sep_cols)) {
    sep_cols <- colnames(df_in)
  }

  if (is.null(sep)) {
    return(sep)
  }

  if (!is.character(sep)) {
    stop("'sep' must be a character.")
  }

  sep <- gsub("[[:space:]]", "", sep)

  has_sep <- grepl(sep, df_in[, sep_cols, drop = FALSE], fixed = TRUE)

  if (any(has_sep)) {
    stop("The string '", sep, "' is already present in the input data, select a different value for 'sep'.")
  }

  sep
}

#' Determine whether TCR or BCR data were provided
#'
#' @param df_in data.frame containing V(D)J data formatted so that each row
#' represents a single contig
#' @param chain_col Column in input data containing chain identity
#' @return Character string indicating whether TCR or BCR data were provided
#' @noRd
.classify_vdj <- function(df_in, chain_col = "chains") {
  chains <- list(
    "TCR" = c("TRA", "TRB", "TRD", "TRG"),
    "BCR" = c("IGH", "IGK", "IGL")
  )

  n_chains <- purrr::imap(chains, ~ purrr::set_names(rep(.y, length(.x)), .x))
  n_chains <- purrr::flatten(n_chains)

  n_chains <- as.character(n_chains[df_in[[chain_col]]])
  n_chains <- table(n_chains)

  # Error if no chains match
  if (all(n_chains[names(chains)] == 0)) {
    chains <- unlist(chains, use.names = FALSE)
    chains <- paste0(chains, collapse = ", ")

    stop(
      "None of the expected chains (", chains, ") were found in '",
      chain_col, "', unable to determine whether TCR or BCR data were ",
      "provided."
    )
  }

  # Calculate fraction of BCR/TCR chains
  # set type if >50% match
  res <- n_chains / sum(n_chains)
  res <- names(res[res > 0.5])

  if (purrr::is_empty(res)) {
    res <- "Multi"

    warning(
      "Equal number of BCR (", n_chains[["BCR"]], ") and TCR (",
      n_chains[["TCR"]], ") chains detected, unable to determine data type."
    )
  }

  res
}

#' Check cell barcode overlap with object
#'
#' @param input Single cell object
#' @param meta meta.data to check against object
#' @param nm Sample name to use for messages
#' @param pct_min Warn user if the percent overlap is less than pct_min
#' @return input data
#' @noRd
.check_overlap <- function(input, meta, nm, pct_min = 25) {

  if (is.null(input)) {
    return(meta)
  }

  obj_meta  <- .get_meta(input)
  obj_cells <- obj_meta[[CELL_COL]]
  met_cells <- unique(meta$barcode)

  n_overlap   <- length(obj_cells[obj_cells %in% met_cells])
  pct_overlap <- round(n_overlap / length(met_cells), 2) * 100

  if (nm != "") {
    nm <- paste0(nm, " ")
  }

  if (identical(n_overlap, 0L)) {
    stop(nm, "cell barcodes do not match those in the object, are you using the correct cell barcode prefixes?")
  }

  if (pct_overlap < pct_min) {
    warning("Only ", pct_overlap, "% (", n_overlap, ") of ", nm, "cell barcodes overlap with the provided object")
  }

  meta
}

#' Identify clonotypes with paired chains
#'
#' @param df_in data.frame containing V(D)J data formatted so each row
#' represents a single contig
#' @return Input data.frame with paired column added
#' @noRd
.identify_paired <- function(df_in) {

  res <- dplyr::group_by(df_in, .data$barcode)

  res <- dplyr::mutate(
    res,
    paired = (all(c("TRA", "TRB") %in% .data$chains)) |
      ("IGH" %in% .data$chains & any(c("IGL", "IGK") %in% .data$chains))
  )

  res <- dplyr::ungroup(res)

  res
}

#' Add isotypes to V(D)J data
#'
#' @param df_in data.frame containing V(D)J data formatted so each row
#' represents a single contig
#' @param iso_col Column containing data to use for extracting isotypes
#' @param chain_col Column in input data containing chain identity
#' @return Input data.frame with isotype column added
#' @noRd
.extract_isotypes <- function(df_in, iso_col = "c_gene", chain_col = "chains") {

  # Pull data for isotypes
  isos <- df_in[[iso_col]]

  chains <- df_in[[chain_col]]

  idx <- chains == "IGH" & isos != "None"

  isos[idx] <- substr(isos[idx], 1, 4)

  isos[!idx] <- as.character(NA)

  # Identify cells with multiple isotypes
  iso_df <- df_in[, c("barcode", iso_col)]

  iso_df[iso_col] <- isos

  iso_df <- dplyr::distinct(iso_df, barcode, c_gene)
  iso_df <- stats::na.omit(iso_df)

  dups <- iso_df$barcode
  dups <- dups[duplicated(dups)]

  # Add isotypes to meta.data
  iso_df <- mutate(
    iso_df,
    isotype = ifelse(barcode %in% dups, "Multi", !!sym(iso_col))
  )

  isos <- purrr::set_names(
    iso_df$isotype,
    iso_df$barcode
  )

  res <- mutate(
    df_in,
    isotype = unname(isos[barcode]),
    isotype = tidyr::replace_na(isotype, "None")
  )

  res
}

#' Define clonotypes based on V(D)J data
#'
#' This will assign new clonotype IDs based on the combination of values
#' present in the provided columns
#'
#' @param input Single cell object or data.frame containing V(D)J data. If a
#' data.frame is provided, the cell barcodes should be stored as row names.
#' @param vdj_cols meta.data columns containing V(D)J data to use for defining
#' clonotypes
#' @param clonotype_col Name of column to use for storing clonotype IDs
#' @param filter_chains Column(s) to use for filtering chains prior to defining
#' clonotypes (e.g. productive, full_length). The column(s) must contain TRUE
#' or FALSE for each chain. If NULL, all chains are used when defining
#' clonotypes.
#' @param sep Separator used for storing per cell V(D)J data
#' @return Single cell object or data.frame with added clonotype IDs
#'
#' @examples
#' # Define clonotypes using the CDR3 nucleotide sequence
#' res <- define_clonotypes(
#'   vdj_so,
#'   vdj_cols = "cdr3_nt"
#' )
#'
#' head(res@meta.data, 1)
#'
#' # Define clonotypes based on the combination of the CDR3 nucleotide sequence
#' # and the V and J genes
#' res <- define_clonotypes(
#'   vdj_sce,
#'   vdj_cols = c("cdr3_nt", "v_gene", "j_gene")
#' )
#'
#' head(res@colData, 1)
#'
#' # Modify the name of the column used to store clonotype IDs
#' res <- define_clonotypes(
#'   vdj_so,
#'   vdj_cols = "cdr3_nt",
#'   clonotype_col = "NEW_clonotype_id"
#' )
#'
#' head(res@meta.data, 1)
#'
#' # When defining clonotypes only use chains that are productive
#' res <- define_clonotypes(
#'   vdj_sce,
#'   vdj_cols = "cdr3_nt",
#'   filter_chains = "productive"
#' )
#'
#' head(res@colData, 1)
#'
#' @export
define_clonotypes <- function(input, vdj_cols, clonotype_col = "clonotype_id",
                              filter_chains = c("productive", "full_length"), sep = ";") {

  # Get meta.data
  meta <- .get_meta(input)

  if (!all(vdj_cols %in% colnames(meta))) {
    stop("Not all vdj_cols (", paste0(vdj_cols, collapse = ", "), ") are present in meta.data.")
  }

  # Only use values in vdj_cols that are TRUE for all filter_chains columns
  # first identify contigs TRUE for all filter_chains columns
  # subset each vdj_cols column based on .clone_idx
  if (!is.null(filter_chains)) {

    clmns <- syms(filter_chains)

    meta <- mutate_vdj(
      input,

      .clone_idx = list(
        purrr::reduce(list(!!!clmns), ~ .x & .y)
      ),

      dplyr::across(
        dplyr::all_of(vdj_cols),
        ~ paste0(.x[.data$.clone_idx], collapse = ""),
        .names = ".clone_{.col}"
      ),

      clonotype_col = NULL,

      vdj_cols = c(vdj_cols, filter_chains)
    )

    vdj_cols <- paste0(".clone_", vdj_cols)

    meta <- .get_meta(meta)
  }

  # Add new clonotype IDs
  meta <- dplyr::mutate(
    meta,
    .new_clone = paste(!!!syms(vdj_cols), sep = ""),
    .new_id    = rank(.data$.new_clone, ties.method = "min"),

    !!sym(clonotype_col) := ifelse(
      .data$.new_clone == "",
      "None",
      paste0("clonotype", .data$.new_id)
    )
  )

  # Remove temporary columns
  meta <- dplyr::select(
    meta,
    -dplyr::matches("^.new_(clone|id)"),
    -dplyr::starts_with(".clone_")
  )

  # Format results
  res <- .add_meta(input, meta)

  res
}





# #' Load insertion/deletion information for each contig
# #'
# #' VERSION TO LOAD INDELS FROM CONCAT_REF BAM
# #'
# #' @param vdj_dir Directory containing the output from cellranger vdj. A vector
# #' or named vector can be given to load data from several runs. If a named
# #' vector is given, the cell barcodes will be prefixed with the provided names.
# #' This mimics the behavior of the Read10X function found in the Seurat
# #' package.
# #' @param bam_file bam file from cellranger vdj containing alignment data comparing
# #' each contig with the germline reference
# #' @return List containing one data.frame for each path provided to vdj_dir
# #' @importFrom Rsamtools scanBam
# #' @noRd
# .load_bam_indels <- function(vdj_dir, bam_file = "concat_ref.bam") {
#
#   .extract_indels <- function(bam_lst) {
#
#     res <- tibble::tibble(
#       cigar     = bam_lst[[1]]$cigar,
#       contig_id = bam_lst[[1]]$qname
#     )
#
#     res <- dplyr::filter(res, grepl("_contig_[0-9]+$", .data$contig_id))
#
#     # Add indel columns
#     res <- dplyr::mutate(
#       res,
#       n_insertion = .extract_pat(.data$cigar, "[0-9]+(?=I)"),
#       n_deletion  = .extract_pat(.data$cigar, "[0-9]+(?=D)"),
#       n_mismatch  = .extract_pat(.data$cigar, "[0-9]+(?=X)"),
#     )
#
#     res <- dplyr::select(res, -.data$cigar)
#
#     res
#   }
#
#   .extract_pat <- function(string, pat) {
#     res <- purrr::map_dbl(string, ~ {
#       strg  <- .x
#       mtch  <- gregexpr(pat, strg, perl = TRUE)[[1]]
#       strts <- as.integer(mtch)
#       lens  <- attr(mtch, "match.length", exact = TRUE)
#
#       n <- purrr::map2_int(strts, lens, ~ {
#         x <- substr(strg, .x, .x + .y - 1)
#         x <- as.integer(x)
#         x
#       })
#
#       # Multiple indel sites will result in vector with length > 1
#       # sum bp from all sites and replace NAs with 0
#       n <- tidyr::replace_na(sum(n), 0)
#
#       n
#     })
#
#     res
#   }
#
#   # Check for file and return path
#   # if bam is missing for any sample, return NULL
#   # do not want extra NAs in the V(D)J data columns
#   res <- purrr::map_chr(vdj_dir, .get_vdj_path, file = bam_file, warn = TRUE)
#
#   if (any(is.na(res))) {
#     return(NULL)
#   }
#
#   # Load data
#   res <- purrr::map(res, Rsamtools::scanBam)
#
#   # Extract indel data
#   res <- purrr::map(res, .extract_indels)
#
#   res
# }

# #' Load insertion/deletion information for each contig
# #'
# #' @param vdj_dir Directory containing the output from cellranger vdj. A vector
# #' or named vector can be given to load data from several runs. If a named
# #' vector is given, the cell barcodes will be prefixed with the provided names.
# #' This mimics the behavior of the Read10X function found in the Seurat
# #' package.
# #' @param airr_file file following AIRR format from cellranger vdj
# #' @return List containing one data.frame for each path provided to vdj_dir
# #' @importFrom Rsamtools scanBam
# #' @noRd
# .load_airr_indels <- function(vdj_dir, airr_file = "airr_rearrangement.tsv") {
#
#   len_cols <- c("junction_aa_length", "junction_length")
#
#   # Check for file and return path
#   # if airr is missing for any sample, return NULL
#   # do not want extra NAs in the V(D)J data columns
#   res <- purrr::map_chr(vdj_dir, .get_vdj_path, file = airr_file, warn = TRUE)
#
#   if (any(is.na(res))) {
#     return(NULL)
#   }
#
#   # Load data
#   res <- purrr::map(
#     res,
#     readr::read_tsv,
#     col_types = readr::cols(),
#     progress  = FALSE
#   )
#
#   # Add indel columns
#   clmns <- c("_insertions", "_deletions", "_mismatches")
#
#   res <- purrr::map(res, ~ {
#     .x <- .extract_indels(.x, "v_cigar", "v_")
#     .x <- .extract_indels(.x, "d_cigar", "d_")
#     .x <- .extract_indels(.x, "j_cigar", "j_")
#
#     .x <- dplyr::select(
#       .x,
#       contig_id = sequence_id,
#       all_of(len_cols),
#       ends_with(clmns)
#     )
#
#     .x
#   })
#
#   # Sum indels
#   clmns <- purrr::set_names(clmns)
#   clmns <- map(clmns, ~ str_c(c("v", "d", "j"), .x))
#
#   res <- purrr::map(res, ~ {
#     .x <- dplyr::rowwise(.x)
#
#     .x <- mutate(
#       .x,
#       all_insertions = sum(!!!syms(clmns$`_insertions`)),
#       all_deletions  = sum(!!!syms(clmns$`_deletions`)),
#       all_mismatches = sum(!!!syms(clmns$`_mismatches`))
#     )
#
#     .x <- dplyr::ungroup(.x)
#
#     .x
#   })
#
#   res
# }
# .extract_indels <- function(df_in, clmn, prfx) {
#   new_clmns <- c(
#     insertions = "[0-9]+(?=I)",
#     deletions  = "[0-9]+(?=D)",
#     mismatches = "[0-9]+(?=X)"
#   )
#
#   names(new_clmns) <- paste0(prfx, names(new_clmns))
#
#   res <- df_in
#
#   for (i in seq_along(new_clmns)) {
#     new <- names(new_clmns[i])
#     pat <- new_clmns[[i]]
#
#     res <- mutate(
#       res,
#       !!sym(new) := .extract_pat(!!sym(clmn), pat)
#     )
#   }
#
#   res
# }
# .extract_pat <- function(string, pat) {
#   res <- purrr::map_dbl(string, ~ {
#     strg  <- .x
#     mtch  <- gregexpr(pat, strg, perl = TRUE)[[1]]
#     strts <- as.integer(mtch)
#     lens  <- attr(mtch, "match.length", exact = TRUE)
#
#     n <- purrr::map2_int(strts, lens, ~ {
#       x <- substr(strg, .x, .x + .y - 1)
#       x <- as.integer(x)
#       x
#     })
#
#     # Multiple indel sites will result in vector with length > 1
#     # sum bp from all sites and replace NAs with 0
#     n <- tidyr::replace_na(sum(n), 0)
#
#     n
#   })
#
#   res
# }

