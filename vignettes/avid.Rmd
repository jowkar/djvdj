---
title: "V(D)J analysis"
date: '`r format(Sys.Date(), "%B %d %Y")`'
output:
  rmarkdown::html_vignette:
    toc_float: true
    toc_depth: 2
    vignette: >
      %\VignetteIndexEntry{V(D)J analysis}
      %\VignetteEncoding{UTF-8}
      %\VignetteEngine{knitr::rmarkdown}
---

```{r "setup", include = FALSE}
# Chunk opts
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  warning   = FALSE,
  message   = FALSE
)
```

<br>

For this vignette we are using AVID-seq data. This is a method developed by the Hesselberth lab which involves staining cells with DNA-tagged antigen. The DNA tag is similar to the tags present on CITE-seq antibodies and can be detected using the 10x Genomics 5â€™ immune profiling kit. For this experiment we mixed splenocytes from BL6 and MD4 mice and stained with a HEL-DNA conjugate. MD4 B cells are monoclonal and specifically bind HEL.

```{r "rna_umap", fig.width = 12.5, fig.height = 3, echo = FALSE}
# Packages
library(here)
library(djvdj)
library(dplyr)
library(cowplot)
library(ggplot2)

load(here("data/avid/so_avid.rda"))

# Theme colors
vdj_colors <- c(
  "#E69F00", "#56B4E9",
  "#009E73", "#F0E442",
  "#d7301f", "#0072B2",
  "#D55E00", "#6A51A3",
  "#CC79A7", "#999999",
  "#875C04"
)

# Rename cell types
so_avid <- so_avid %>%
  mutate_meta(
    fn   = mutate,
    type = if_else(!type %in% c("B cell", "T cell"), "other", type)
  )

# Plot colors
m_cols <- c(
  BL6 = "#E69F00",
  MD4 = "#56B4E9"
)

t_cols <- c(
  "B cell" = "#56B4E9",
  "T cell" = "#009E73",
  other    = "#F0E442"
)

# Create mouse UMAP
mouse_umap <- so_avid %>%
  plot_features(
    feature     = "mouse",
    plot_colors = m_cols,
    size        = 0.001
  ) +
  ggtitle("Mouse") +
  theme_nothing() +
  theme(
    plot.title      = element_text(),
    legend.position = "right",
    legend.title    = element_blank()
  )
  
# Create cell type UMAP
type_umap <- so_avid %>%
  plot_features(
    feature     = "type",
    plot_colors = t_cols,
    plot_lvls   = names(t_cols),
    size        = 0.001
  ) +
  ggtitle("Cell type") +
  theme_nothing() +
  theme(
    plot.title      = element_text(),
    legend.position = "right",
    legend.title    = element_blank()
  )

# Create HEL UMAP
hel_umap <- so_avid %>%
  plot_features(
    feature     = "adt_HEL",
    plot_colors = c("grey85", vdj_colors[5]),
    size        = 0.1
  ) +
  ggtitle("HEL signal") +
  guides(color = guide_colorbar(barwidth = unit(6, "pt"))) +
  theme_nothing() +
  theme(
    plot.title      = element_text(),
    legend.position = "right",
    legend.title    = element_blank(),
    legend.text     = element_text(size = 8)
  )

# Final figure
plot_grid(
  mouse_umap, type_umap, hel_umap,
  align = "vh",
  axis  = "trbl",
  nrow  = 1
)
```

<br>

## Import V(D)J data

`import_vdj()` takes the output files from [Cell Ranger](https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/using/vdj#header) and adds clonotype information to the meta.data for an existing [Seurat](https://satijalab.org/seurat/) or SingleCellExperiment object. For cells with multiple chains, the information for each chain is stored as a single row, separated by a semi-colon. For cells that do not have V(D)J sequencing data, `NA`s are added to the meta.data.

If the Seurat object contains data for multiple runs, a vector containing paths to the `cellranger vdj` output files for each sample can be given. When multiple runs are included in the same object, the cell barcodes will commonly contain a unique prefix for each sample. The cell prefixes can be specified using the `cell_prefix` argument.

```{r "import_vdj"}
# Packages
library(djvdj)
library(Seurat)
library(here)
library(tibble)
library(purrr)
library(dplyr)
library(ggplot2)
library(cowplot)

# Create vector of paths pointing to cellranger output
paths <- here("data/avid/bcr/outs")

so_avid <- import_vdj(
  input         = so_avid,                  # Seurat object
  vdj_dir       = paths,                    # cellranger directories
  filter_chains = TRUE,                     # Only include productive chains
  filter_paired = FALSE                     # Only include clonotypes with paired chains
)
```

<br>

Take a look at the meta.data to see the V(D)J data added to the object. 

```{r}
so_avid@meta.data %>%
  as_tibble() %>%
  select(19:35)
```

<br>

## Clonotype Abundance

To identify the top clonotypes in each sample or cluster, clonotype abundance can be calculated using the `calc_abundance()` function. These calculations can be performed on a per-cluster or per-sample basis by also providing a meta.data column containing cell labels.

```{r}
so_avid <- calc_frequency(
  input       = so_avid,
  cluster_col = "mouse",                  # Column containing cell clusters to compare
  data_col    = "clonotype_id"            # Column containing clonotype IDs to use
)
```

<br>

For each 'calc' function provided by djvdj, there is a matching 'plot' function that will generate a summary plot. The `plot_abundance()` function will plot clonotypes ranked by abundance. As expected we see that most MD4 B cells share the same clonotype.

```{r "abund_plots", fig.width = 8, fig.height = 3.5}
clrs <- c(
  BL6 = "#E69F00",
  MD4 = "#56B4E9"
)

plot_clonal_abundance(
  input       = so_avid,
  cluster_col = "mouse",                   # Column containing cell clusters to compare
  n_clones    = 10,                        # Number of top clonotypes to plot
  type        = "bar",                     # Type of plot, 'bar' or 'line'
  plot_colors = clrs
)
```

<br>

## Repertoire Diversity

The function `calc_diversity()` will calculate repertoire diversity based on the number of cells that share each clonotype. The `cluster_col` argument can be used to group cells based on a meta.data column prior to calculating diversity. `calc_diversity()` uses the R package [abdiv](https://github.com/kylebittinger/abdiv) for performing diversity calculations and any [abdiv](https://github.com/kylebittinger/abdiv) diversity function can be specified using the `method` argument. It is important to read the [abdiv](https://github.com/kylebittinger/abdiv) documentation to ensure the selected function is appropriate for your analysis. 

Possible methods for calculating diversity include:

```{r, comment = "", echo = F}
abdiv::alpha_diversities
```
<br>

In this example we are calculating the Shannon diversity for each sample in the orig.ident meta.data column.

```{r}
so_avid <- calc_diversity(
  input       = so_avid,
  cluster_col = "mouse",                    # Column containing cell clusters to compare
  method      = abdiv::shannon              # abdiv method to use
)
```

<br>

The `plot_diversity()` function will create plots summarizing repertoire diversity for each sample. A named list of functions can also be passed to plot multiple metrics. Two different metrics are shown in the example below. As expected, BL6 B cells have a very diverse repertoire, while MD4 cells have a restricted repertoire. 

```{r "div_plots", fig.width = 3.5, fig.height = 3}
# Metrics to plot
fns <- list(
  "simpson"  = abdiv::simpson,
  "mcintosh" = abdiv::mcintosh_d
)

plot_diversity(
  input       = so_avid,
  cluster_col = "mouse",                    # Column containing cell clusters to compare
  method      = fns,                        # abdiv method to use
  plot_colors = c("#E69F00", "#56B4E9")
)
```

<br>

## Repertoire Overlap

To compare repertoires for different samples or clusters, `calc_similarity()` can calculate a variety of different similarity metrics. The `cluster_col` argument should be used to specify the meta.data column containing cell groups to use for comparison. Like `calc_diversity()`, an [abdiv](https://github.com/kylebittinger/abdiv) function can be specified with the `method` argument. It is important to read the [abdiv](https://github.com/kylebittinger/abdiv) documentation to ensure the selected function is appropriate for your analysis.

Possible methods for calculating repertoire similarity include:

```{r, comment = "", echo = F}
abdiv::beta_diversities
```

<br>

By default `calc_similarity()` will add a new meta.data column for each comparison. In this example we are calculating the jaccard dissimilarity index for all combinations of clusters present in the `seurat_clusters` column.

```{r}
so_avid <- calc_similarity(
  input       = so_avid,
  cluster_col = "seurat_clusters",          # Column containing cell clusters to compare
  method      = abdiv::jaccard              # abdiv method to use
)
```

<br>

A heatmap summarizing the results can be generated using the `plot_similarity()` function. Values closer to 1 indicate minimal overlap between the clusters.

```{r "sim_plots", fig.width = 5, fig.height = 4}
plot_similarity(
  input       = so_avid,
  cluster_col = "seurat_clusters",          # Column containing cell clusters to compare
  method      = abdiv::jaccard,             # abdiv method to use
  plot_colors = "#009E73",
  color       = "white"                     # Additional ggplot options
)
```

<br>

## Gene Usage

The V(D)J data imported from Cell Ranger also includes the V(D)J identified for each chain. The function `calc_gene_usage()` will calculate the fraction of cells expressing each V(D)J gene and produce a table summarizing the results. The `chain` argument can be used to specify the chain(s) to use for calculating gene usage, by default results for all chains will be included.

In this example we are summarizing the usage of different V segments for the IGH chain

```{r}
calc_gene_usage(
  input       = so_avid,
  gene_cols   = "v_gene",                   # Column containing genes
  cluster_col = "mouse",                    # Column containing cell clusters to compare
  chain       = "IGH",                      # Chain to calculate gene usage for
  chain_col   = "chains"                    # Column containing chains
)
```

<br>

The function `plot_gene_usage()` can be used visualize gene usage across clusters. Using the `yaxis` argument, the percentage of cells (percent) or total number of cells (frequency) expressing each gene can be shown. The number of top genes (most frequent) to plot can also be specified with `n_genes`.

```{r "gene_usage_1", fig.width = 11, fig.height = 3.5}
plot_gene_usage(
  input       = so_avid,
  gene_cols   = "v_gene",                   # Column(s) containing genes
  type        = "bar",                      # Type of plot, 'heatmap' or 'bar'
  chain       = "IGH",                      # Chain to plot
  n_genes     = 50,                         # The number of top genes to plot
  plot_colors = "#0072B2"
)
```

<br>

By passing multiple columns to `gene_cols`, the frequency of V-J gene pairings can also be summarized. In this example we are only looking at IGK chains.

```{r, eval = F}
calc_gene_usage(
  input       = so_avid,
  gene_cols   = c("v_gene", "j_gene"),      # Column(s) containing genes
  cluster_col = "mouse",                    # Column containing cell clusters to compare
  chain       = "IGK"                       # Chain to plot
)
```

<br>

When multiple gene columns are passed to `plot_gene_usage()`, a list of plots will be returned, one for each cluster in the `cluster_col` column.

```{r "gene_usage_2", fig.width = 12, fig.height = 2.5}
ggs <- plot_gene_usage(
  input       = so_avid,
  gene_cols   = c("v_gene", "j_gene"),      # Column(s) containing genes
  cluster_col = "mouse",                    # Column containing cell clusters to compare
  chain       = "IGK",                      # Chain to plot
  plot_colors = "#6A51A3",
  n_genes     = 20
)

plot_grid(plotlist = ggs)
```

<br>
