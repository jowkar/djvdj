---
title: "V(D)J analysis"
date: '`r format(Sys.Date(), "%B %d %Y")`'
output:
  rmarkdown::html_vignette:
    toc_float: true
    toc_depth: 2
    vignette: >
      %\VignetteIndexEntry{V(D)J analysis}
      %\VignetteEncoding{UTF-8}
      %\VignetteEngine{knitr::rmarkdown}
---

```{r "setup", include = FALSE}
# Chunk opts
knitr::opts_chunk$set(
  collapse  = TRUE,
  comment   = "#>",
  warning   = FALSE,
  message   = FALSE
)
```

<br>

For this vignette we are using AVID-seq data. This is a method developed by the [Hesselberth](https://hesselberthlab.org/) lab which involves staining cells with DNA-tagged antigen. The DNA tag is similar to the tags present on CITE-seq antibodies and can be detected using the 10x Genomics 5â€™ immune profiling kit. For this experiment we mixed splenocytes from BL6 and MD4 mice and stained with a HEL-DNA conjugate. MD4 B cells are monoclonal and should specifically bind HEL (hen egg lysozyme).

Below we see that signal from the HEL-DNA conjugate is specific for MD4 B cells.

```{r "rna_umap", fig.width = 12.5, fig.height = 3, echo = FALSE}
# Packages
library(here)
library(djvdj)
library(dplyr)
library(cowplot)
library(ggplot2)

load(here("data/avid/so_avid.rda"))

# Theme colors
vdj_colors <- c(
  "#E69F00", "#56B4E9",
  "#009E73", "#F0E442",
  "#d7301f", "#0072B2",
  "#D55E00", "#6A51A3",
  "#CC79A7", "#999999",
  "#875C04"
)

# Rename cell types
so_avid <- so_avid %>%
  mutate_meta(
    fn   = mutate,
    type = if_else(!type %in% c("B cell", "T cell"), "other", type)
  )

# Plot colors
m_cols <- c(
  BL6 = "#E69F00",
  MD4 = "#56B4E9"
)

t_cols <- c(
  "B cell" = "#56B4E9",
  "T cell" = "#009E73",
  other    = "#F0E442"
)

# Create mouse UMAP
mouse_umap <- so_avid %>%
  plot_features(
    feature     = "mouse",
    plot_colors = m_cols,
    size        = 0.001
  ) +
  ggtitle("Mouse") +
  theme_nothing() +
  theme(
    plot.title      = element_text(),
    legend.position = "right",
    legend.title    = element_blank()
  )
  
# Create cell type UMAP
type_umap <- so_avid %>%
  plot_features(
    feature     = "type",
    plot_colors = t_cols,
    plot_lvls   = names(t_cols),
    size        = 0.001
  ) +
  ggtitle("Cell type") +
  theme_nothing() +
  theme(
    plot.title      = element_text(),
    legend.position = "right",
    legend.title    = element_blank()
  )

# Create HEL UMAP
hel_umap <- so_avid %>%
  plot_features(
    feature     = "adt_HEL",
    plot_colors = c("grey85", vdj_colors[5]),
    size        = 0.1
  ) +
  ggtitle("HEL signal") +
  guides(color = guide_colorbar(barwidth = unit(6, "pt"))) +
  theme_nothing() +
  theme(
    plot.title      = element_text(),
    legend.position = "right",
    legend.title    = element_blank(),
    legend.text     = element_text(size = 8)
  )

# Final figure
plot_grid(
  mouse_umap, type_umap, hel_umap,
  align = "vh",
  axis  = "trbl",
  nrow  = 1
)
```

<br>

## Import V(D)J data

`import_vdj()` takes the output files from [Cell Ranger](https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/using/vdj#header) and adds clonotype information to the meta.data for an existing [Seurat](https://satijalab.org/seurat/) or SingleCellExperiment object. For cells with multiple chains, the information for each chain is stored as a single row, separated by a semi-colon. For cells that do not have V(D)J sequencing data, `NA`s are added to the meta.data.

If the Seurat object contains data for multiple runs, a vector containing paths to the `cellranger vdj` output files for each sample can be given.

```{r "import_vdj"}
# Packages
library(djvdj)
library(Seurat)
library(here)
library(tibble)
library(purrr)
library(dplyr)
library(ggplot2)
# library(cowplot)

# Create vector of paths pointing to cellranger output
paths <- here("data/avid/bcr/outs")

so_avid <- import_vdj(
  input         = so_avid,                  # Seurat object
  vdj_dir       = paths,                    # cellranger directories
  filter_chains = TRUE,                     # Only include productive chains
  filter_paired = FALSE                     # Only include clonotypes with paired chains
)
```

<br>

Take a look at the meta.data to see the V(D)J data added to the object. 

```{r}
so_avid@meta.data %>%
  as_tibble() %>%
  select(19:35)
```

<br>

## Clonotype Abundance

To identify the top clonotypes in each sample or cluster, clonotype abundance can be calculated using the `calc_frequency()` function. These calculations can be performed on a per-cluster or per-sample basis by providing a meta.data column containing cell labels to use for comparison.

```{r}
so_avid <- calc_frequency(
  input       = so_avid,
  data_col    = "clonotype_id",    # Column containing clonotype IDs
  cluster_col = "mouse"            # Column containing cell clusters to compare
)
```

<br>

For each 'calc' function provided by djvdj, there is a matching 'plot' function that will generate a summary plot. The `plot_clonal_abundance()` function will plot clonotypes ranked by abundance. As expected we see that most MD4 B cells share the same clonotype.

```{r "abund_plots", fig.width = 8, fig.height = 3.5}
clrs <- c(
  BL6 = "#E69F00",
  MD4 = "#56B4E9"
)

plot_clonal_abundance(
  input       = so_avid,
  cluster_col = "mouse",           # Column containing cell clusters to compare
  n_clones    = 10,                # Number of top clonotypes to plot
  type        = "bar",             # Type of plot, 'bar' or 'line'
  plot_colors = clrs
)
```

<br>

## Repertoire Diversity

The function `calc_diversity()` will calculate repertoire diversity based on the number of cells that share each clonotype. The `cluster_col` argument can be used to group cells based on a meta.data column prior to calculating diversity. `calc_diversity()` uses the R package [abdiv](https://github.com/kylebittinger/abdiv) for performing diversity calculations and any [abdiv](https://github.com/kylebittinger/abdiv) diversity function can be specified using the `method` argument. It is important to read the [abdiv](https://github.com/kylebittinger/abdiv) documentation to ensure the selected function is appropriate. 

Possible methods for calculating diversity include:

```{r, comment = "", echo = F}
abdiv::alpha_diversities
```
<br>

In this example we are calculating the Shannon entropy for BL6 and MD4 samples.

```{r}
so_avid <- calc_diversity(
  input       = so_avid,
  data_col    = "clonotype_id",    # Column containing clonotype IDs
  cluster_col = "mouse",           # Column containing cell clusters to compare
  method      = abdiv::shannon     # abdiv method to use
)
```

<br>

The `plot_diversity()` function will create plots summarizing repertoire diversity for each sample. A named list of functions can also be passed to plot multiple metrics. Two metrics for measuring diversity are the Simpson index and Shannon entropy. Both of these metrics are influenced by species richness (number of unique sequences) and evenness (relative abundance of sequences). To specifically measure species evenness, Pielou's index can be used. For these three metrics, maximally diverse samples will have values approaching 1.

As expected, BL6 B cells have a very diverse repertoire, while MD4 cells have a restricted repertoire. 

```{r "div_plots", fig.width = 6, fig.height = 3}
# Metrics to plot
fns <- list(
  "simpson"  = abdiv::simpson,
  "shannon"  = abdiv::simpson,
  "pielou evenness" = abdiv::pielou_e
)

plot_diversity(
  input       = so_avid,
  data_col    = "clonotype_id",    # Column containing clonotype IDs
  cluster_col = "mouse",           # Column containing cell clusters to compare
  method      = fns,               # abdiv method to use
  plot_colors = clrs
)
```

<br>

## Repertoire Overlap

To compare repertoires for different samples or clusters, `calc_similarity()` can calculate a variety of different similarity metrics. The `cluster_col` argument should be used to specify the meta.data column containing cell groups to use for comparison. Like `calc_diversity()`, an [abdiv](https://github.com/kylebittinger/abdiv) function can be specified with the `method` argument. It is important to read the [abdiv](https://github.com/kylebittinger/abdiv) documentation to ensure the selected function is appropriate.

<br>

By default `calc_similarity()` will add a new meta.data column for each comparison. In this example we are calculating the jaccard dissimilarity index for all combinations of clusters present in the `seurat_clusters` column.

```{r}
so_avid <- calc_similarity(
  input       = so_avid,
  data_col    = "clonotype_id",       # Column containing clonotype IDs
  cluster_col = "seurat_clusters",    # Column containing cell clusters to compare
  method      = abdiv::jaccard        # abdiv method to use
)
```

<br>

Sample similarity can be visualized using the `plot_similarity()` function. By default the Jaccard dissimilarity index is used to generate a heatmap, with values closer to 1 indicating minimal overlap between samples.

```{r "sim_plots", fig.width = 5, fig.height = 4}
plot_similarity(
  input       = so_avid,
  data_col    = "clonotype_id",       # Column containing clonotype IDs
  cluster_col = "seurat_clusters",    # Column containing cell clusters to compare
  plot_colors = c("#56B4E9", "white", "#009E73"),
  remove_upper_triangle = TRUE,
  cluster_heatmap = FALSE
)
```

<br>

A circos plot can be generated to summarize the number of clonotypes shared between samples.

```{r "sim_plots_circos", fig.width = 5, fig.height = 5}
plot_similarity(
  input       = so_avid,
  data_col    = "clonotype_id",       # Column containing clonotype IDs
  cluster_col = "seurat_clusters",    # Column containing cell clusters to compare
  method      = "circos"
)
```

<br>

## Gene Usage

The V(D)J data imported from Cell Ranger also includes the V(D)J identified for each chain. The function `calc_gene_usage()` will calculate the fraction of cells expressing each V(D)J gene and produce a table summarizing the results. The `chain` argument can be used to specify the chain(s) to use for calculating gene usage, by default results for all chains will be included.

In this example we are summarizing the usage of different V segments for the IGH chain

```{r}
calc_gene_usage(
  input       = so_avid,
  gene_cols   = "v_gene",          # Column containing genes
  cluster_col = "mouse",           # Column containing cell clusters to compare
  chain       = "IGH",             # Chain to calculate gene usage for
  chain_col   = "chains"           # Column containing chains
)
```

<br>

The function `plot_gene_usage()` can be used visualize gene usage across clusters. Using the `yaxis` argument, the percentage of cells (percent) or total number of cells (frequency) expressing each gene can be shown. The number of top genes (most frequent) to plot can also be specified with `n_genes`.

```{r "gene_usage_1", fig.width = 11, fig.height = 3.5}
plot_gene_usage(
  input       = so_avid,
  gene_cols   = "v_gene",          # Column(s) containing genes
  type        = "bar",             # Type of plot, 'heatmap' or 'bar'
  chain       = "IGH",             # Chain to plot
  n_genes     = 50,                # Number of top genes to plot
  plot_colors = "#0072B2"
)
```

<br>

By passing multiple columns to `gene_cols`, the frequency of V-J gene pairings can also be summarized. This will return a list of plots, one for each cluster in the `cluster_col` column.

```{r "gene_usage_2", fig.width = 12, fig.height = 2}
ggs <- plot_gene_usage(
  input       = so_avid,
  gene_cols   = c("v_gene", "j_gene"),   # Column(s) containing genes
  cluster_col = "mouse",                 # Column containing cell clusters to compare
  chain       = "IGK",                   # Chain to plot
  plot_colors = "#6A51A3",
  n_genes     = 20
)

reduce(ggs, `+`)
```

<br>

## Clustering

Cells can be clustered based on CDR3 sequences, or any other sequences present in the object. By default, distances are calculated for amino acid sequences using the [BLOSUM62](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC50453/) substitution matrix, which is based on observed amino acid frequencies and substitution probabilities. Clustering resolution can be adjusted using the `resolution` argument. The resulting cluster IDs and new UMAP coordinates are added to the object meta.data.  

```{r "clustering"}
set.seed(42)

so_avid <- cluster_seqs(
  input    = so_avid,
  data_col = "cdr3",      # Column containing sequences to cluster
  chain    = "IGK"        # Chain to use for clustering sequences
)
```

<br>

Clustering results can be visualized using the generic plotting function `plot_features()`.

```{r "clustering_2", fig.width = 6, fig.height = 4}
plot_features(
  input   = so_avid,
  x       = "cdr3_UMAP_1",
  y       = "cdr3_UMAP_2",
  feature = "cdr3_cluster_0.5"
)
```

<br>

A sequence motif can be plotted for each cluster using the `plot_seq_motifs()` function. Cluster 10 includes the MD4 cells and has a sequence motif matching the expected IGK sequence.

```{r "clustering_3", fig.width = 8, fig.height = 5}
plot_seq_motifs(
  input       = so_avid,
  data_col    = "cdr3",              # Column containing sequences to plot
  cluster_col = "cdr3_cluster_0.5",  # Column containing cell clusters to compare
  chain       = "IGK",               # Chain to use for plotting sequences
  width       = 11                   # Minimum width of sequence
)
```

